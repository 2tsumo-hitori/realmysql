# InnoDB 스토리지 엔진 아키텍처

## 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본키 값 순서대로 디스크에 저장됨.
- 결과적으로 쿼리의 실행계획에서 다른 보조 인덱스에 비해 비중이 높게 설정됨.

## 4.2.2 외래 키 지원

- foreign_key_checks 시스템 변수 off 설정으로 외래키 관계 체크를 일시적으로 멈추고, 레코드 적재, 삭제 등의 작업에 부가적인 체크가 필요없음.
- 다만, 반드시 일관성을 맞춰준 후 외래 키 체크 기능을 활성화해야함.

## 4.2.3 MVCC

- MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것.
- InnoDB는 언두 로그를 이용해 기능을 구현함.
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 존재한다는 것.
- 예를 들어 격리 수준이 READ_COPMMITTED인 MySQL 서버에서, 특정 컬럼을 INSERT 후 Commit하고, update 쿼리를 실행 했을 때 InnoDB 버퍼 풀에서는 바로 데이터의 수정이 이뤄지지만, 언두 로그에서는 수정되지 않은 채 그대로 남아있다.
- 여기서 해당 데이터를 조회했을 때, 어디에 있는 데이터를 조회하는지는 MySQL 서버의 시스템 변수에 설정된 격리 수준에 따라 다르다.

## 4.2.4 잠금 없는 일관된 읽기

- InnoDB 스토리지 엔진은 MVCC 기술을이용해 잠금을 걸지 않고 읽기 작업을 수행함.
- 즉, 다른 트랜잭션의 락을 기다리지 않을 수 있음.
- 트랜잭션이 오랜 시간 활성화 상태라면 MySQL 서버가 느려질 수 있기 때문에, 시작됐다면 롤백 혹은 커밋으로 빨리 완료해줘야함.

## 4.2.5 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 락이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프로 관리함.
- 어느 트랜잭션을 먼저 강제 종료 할 것인지에 대한 판단 기준은 트랜잭션의 언두 로그 양이다.
- 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금을 볼 수가 없는데, inndb_table_locks 시스템 변수를 활성화 해서 테이블 레벨의 잠금까지 감지할 수 있다.
- 그러나 동시 처리 스레드가 매우 많거나, 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려지는데, 그렇게 되면 성능 하락 뿐만아니라 CPU 자원을 더 많이 소모할 수도 있다.
- MySQL 서버는 innodb_deadlock_detect 시스템 변수를 OFF로 설정하게 되면 데드락 감지 스레드는 더이상 작동하지 않는다. 이렇게 되면 데드락이 발생하게 되면 무한정 대기에 걸리게된다.
- 이 때, innodb_lock_wait_timeout 시스템 변수를 활성화 하게 되면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하게된다. (사용 권장)

## 4.2.7 InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 함.

### 4.2.7.1 버퍼 풀의 크기 설정

- InnoDB 버퍼 풀은 innodb_buffer_pool_size 시스템 변수로 크기를 설정할 수 있고, 동적으로 버퍼 풀의 크기를 확장 가능
- innodb_buffer_pool_instances 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있는데, 각 버퍼 풀을 버퍼 풀 인스턴스라고 표현함.

### 4.2.7.2 버퍼 풀의 구조

- 프리 리스트 : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록, 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용됨
- LRU 리스트 : 디스크로부터 읽어 온 페이지를 최대한 오랫동안 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화 하려고 사용함.
- 플러시 리스트 : 변경이 가해진 데이터를 플러시 리스트에서 관리하고, 특정 시점이 되면 디스크로 기록함.

## 4.2.10 체인지 버퍼

- 